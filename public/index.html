<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Spark Splat + GLB Viewer (no UI)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      html, body { height:100%; margin:0; background:#0d0f14; }
      #app { width:100%; height:100%; }
      canvas { display:block; width:100%; height:100%; touch-action:none; }
    </style>

    <!-- Import map MUST come before the module script -->
    <script type="importmap">
      {
        "imports": {
          "three": "./spark/three.module.js",
          "@sparkjsdev/spark": "./spark/spark.module.js",
          "three/examples/jsm/loaders/GLTFLoader.js": "./three/examples/jsm/loaders/GLTFLoader.js"
        }
      }
    </script>
  </head>

  <body>
    <div id="app"></div>

    <script type="module">
      import * as THREE from "three";
      import { SparkRenderer, SplatMesh, SparkControls } from "@sparkjsdev/spark";
      import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

      // --- Defaults (autoload) ---
      const DEFAULT_SPZ = "./assets/example.spz";   // required (change path if needed)
      const DEFAULT_GLB = "./assets/branding.glb";  // optional

      // --- Three + Spark setup ---
      const app = document.getElementById("app");
      const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.setSize(innerWidth, innerHeight);
      app.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d0f14);

      const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 2000);

      // Simple lighting for GLB
      scene.add(new THREE.AmbientLight(0xffffff, 1.0));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(2, 3, 4);
      scene.add(dir);

      const spark = new SparkRenderer({ renderer });
      scene.add(spark);

      const controls = new SparkControls({ canvas: renderer.domElement });

      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      renderer.setAnimationLoop(() => {
        controls.update(camera);
        renderer.render(scene, camera);
      });

      // --- Helpers ---
      function frameAll(objs) {
        const box = new THREE.Box3();
        objs.filter(Boolean).forEach(o => box.expandByObject(o));
        if (box.isEmpty()) return;
        const size = new THREE.Vector3(), center = new THREE.Vector3();
        box.getSize(size); box.getCenter(center);
        const maxSize = Math.max(size.x, size.y, size.z) || 1;
        const dist = maxSize / (2 * Math.tan((Math.PI * camera.fov) / 360));
        camera.position.set(center.x, center.y, center.z + dist * 1.5);
      }

      let currentSplat = null;
      let currentModel = null;

      function clearObject(obj) {
        if (!obj) return;
        scene.remove(obj);
        if (obj.traverse) {
          obj.traverse(o => {
            if (o.isMesh) {
              o.geometry?.dispose?.();
              if (Array.isArray(o.material)) o.material.forEach(m => m?.dispose?.());
              else o.material?.dispose?.();
            }
          });
        } else {
          obj.geometry?.dispose?.();
          if (Array.isArray(obj.material)) obj.material.forEach(m => m?.dispose?.());
          else obj.material?.dispose?.();
          obj.dispose?.();
        }
      }

      async function loadSplatURL(url) {
        clearObject(currentSplat);
        const s = new SplatMesh({ url });
        s.quaternion.set(1, 0, 0, 0);
        scene.add(s);
        await s.initialized;             // requires Spark .wasm to be present under /spark/
        currentSplat = s;
        frameAll([currentSplat, currentModel]);
      }

      async function loadGlbURL(url) {
        try {
          const res = await fetch(url);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const bytes = await res.arrayBuffer();
          const blob = new Blob([bytes], { type: "model/gltf-binary" });
          const blobURL = URL.createObjectURL(blob);
          try {
            const gltf = await new GLTFLoader().loadAsync(blobURL);
            const root = gltf.scene || gltf.scenes?.[0];
            if (!root) throw new Error("GLB had no scene");
            scene.add(root);
            currentModel = root;
            frameAll([currentSplat, currentModel]);
          } finally {
            URL.revokeObjectURL(blobURL);
          }
        } catch (e) {
          // branding is optional; fail silently
          console.warn("Branding GLB not loaded:", e?.message || e);
        }
      }

      // --- Autoload on startup ---
      loadSplatURL(DEFAULT_SPZ).catch(err => console.error("Splat autoload failed:", err));
      loadGlbURL(DEFAULT_GLB);
    </script>
  </body>
</html>
